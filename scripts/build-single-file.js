#!/usr/bin/env node
/**
 * Build a single-file Xpod launcher.
 */

const fs = require('node:fs');
const os = require('node:os');
const path = require('node:path');
const crypto = require('node:crypto');
const childProcess = require('node:child_process');

const rootDir = path.resolve(__dirname, '..');
const distDir = path.join(rootDir, 'dist');

const argv = process.argv.slice(2);
const args = new Set(argv);
const shouldIncludeNodeModules = !args.has('--no-node-modules');
const outputArg = argv.find(function(arg) { return arg.indexOf('--output=') === 0; });
const outputPath = outputArg
  ? path.resolve(rootDir, outputArg.slice('--output='.length))
  : path.join(distDir, 'xpod-single.cjs');

if (args.has('--help')) {
  console.log('Usage: node scripts/build-single-file.js [options]\n');
  console.log('Options:');
  console.log('  --output=<file>      Output file path (default: dist/xpod-single.cjs)');
  console.log('  --no-node-modules    Skip embedding node_modules (smaller, not standalone)');
  console.log('  --help               Show this help message');
  process.exit(0);
}

const requiredEntries = [
  'dist/main.js',
  'dist/api/main.js',
  'config',
  'static',
  'templates',
];

for (const rel of requiredEntries) {
  if (!fs.existsSync(path.join(rootDir, rel))) {
    console.error('Missing required build artifact: ' + rel);
    console.error('Please run yarn build first.');
    process.exit(1);
  }
}

const includeEntries = [
  'dist',
  'config',
  'static',
  'templates',
  'package.json',
  'yarn.lock',
  'example.env',
  'example.env.local',
  'example.env.cloud',
];

if (shouldIncludeNodeModules) {
  includeEntries.push('node_modules');
}

if (fs.existsSync(path.join(rootDir, 'lib'))) {
  includeEntries.push('lib');
}

const existingEntries = includeEntries.filter(function(entry) {
  return fs.existsSync(path.join(rootDir, entry));
});

if (!existingEntries.length) {
  console.error('No files found to package.');
  process.exit(1);
}

console.log('Building single-file package...');
console.log('- include node_modules: ' + (shouldIncludeNodeModules ? 'yes' : 'no'));
console.log('- output: ' + path.relative(rootDir, outputPath));

const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'xpod-single-'));
const archivePath = path.join(tempDir, 'payload.tar.gz');

const outputRelative = path.relative(rootDir, outputPath);
const outputInsideRoot = outputRelative && !outputRelative.startsWith('..') && !path.isAbsolute(outputRelative);
const tarArgs = ['-czf', archivePath];
if (outputInsideRoot) {
  tarArgs.push('--exclude=' + outputRelative, '--exclude=./' + outputRelative);
}
tarArgs.push.apply(tarArgs, existingEntries);

const tarResult = childProcess.spawnSync('tar', tarArgs, {
  cwd: rootDir,
  stdio: 'inherit',
  env: Object.assign({}, process.env, { LC_ALL: process.env.LC_ALL || 'C' }),
});

if (tarResult.status !== 0) {
  console.error('Failed to create tar archive. Please ensure tar is available.');
  process.exit(tarResult.status || 1);
}

const archiveBuffer = fs.readFileSync(archivePath);
const archiveHash = crypto.createHash('sha256').update(archiveBuffer).digest('hex');
const archiveBase64 = archiveBuffer.toString('base64');

const launcher = [
  '#!/usr/bin/env node',
  '// Auto-generated by scripts/build-single-file.js',
  "const fs = require('node:fs');",
  "const os = require('node:os');",
  "const path = require('node:path');",
  "const crypto = require('node:crypto');",
  "const childProcess = require('node:child_process');",
  '',
  "const ARCHIVE_SHA256 = '" + archiveHash + "';",
  "const ARCHIVE_BASE64 = '" + archiveBase64 + "';",
  '',
  'function resolveCacheRoot() {',
  '  const candidates = [];',
  '  if (process.env.XPOD_SINGLE_CACHE_DIR) candidates.push(process.env.XPOD_SINGLE_CACHE_DIR);',
  "  candidates.push(path.join(os.homedir(), '.xpod', 'single-file-cache'));",
  "  candidates.push(path.join(os.tmpdir(), 'xpod-single-cache'));",
  '  for (const candidate of candidates) {',
  '    try {',
  '      const absolute = path.resolve(candidate);',
  '      fs.mkdirSync(absolute, { recursive: true });',
  '      return absolute;',
  '    } catch {',
  '      // try next candidate',
  '    }',
  '  }',
  "  throw new Error('No writable cache directory found.');",
  '}',
  '',
  'function ensureExtracted(cacheDir) {',
  "  const marker = path.join(cacheDir, '.xpod-single-ready');",
  '  if (fs.existsSync(marker)) return;',
  '  fs.mkdirSync(cacheDir, { recursive: true });',
  "  const archivePath = path.join(cacheDir, 'payload.tar.gz');",
  "  fs.writeFileSync(archivePath, Buffer.from(ARCHIVE_BASE64, 'base64'));",
  "  const hash = crypto.createHash('sha256').update(fs.readFileSync(archivePath)).digest('hex');",
  "  if (hash !== ARCHIVE_SHA256) throw new Error('Archive checksum mismatch.');",
  "  const tar = childProcess.spawnSync('tar', ['-xzf', archivePath, '-C', cacheDir], {",
  "    stdio: 'inherit',",
  "    env: Object.assign({}, process.env, { LC_ALL: process.env.LC_ALL || 'C' }),",
  '  });',
  "  if (tar.status !== 0) throw new Error('Failed to extract payload archive.');",
  '  fs.writeFileSync(marker, new Date().toISOString());',
  '}',
  '',
  'function main() {',
  '  const cacheRoot = resolveCacheRoot();',
  "  const cacheDir = path.join(cacheRoot, ARCHIVE_SHA256.slice(0, 16));",
  '  ensureExtracted(cacheDir);',
  "  const entry = path.join(cacheDir, 'dist', 'main.js');",
  '  const child = childProcess.spawn(process.execPath, [entry].concat(process.argv.slice(2)), {',
  '    cwd: cacheDir,',
  "    stdio: 'inherit',",
  '    env: process.env,',
  '  });',
  "  child.on('exit', function(code, signal) {",
  '    if (signal) { process.kill(process.pid, signal); return; }',
  '    process.exit(code || 0);',
  '  });',
  '}',
  '',
  'main();',
  '',
].join('\n');

fs.mkdirSync(path.dirname(outputPath), { recursive: true });
fs.writeFileSync(outputPath, launcher, { mode: 0o755 });

const sizeMb = (fs.statSync(outputPath).size / 1024 / 1024).toFixed(2);
console.log('Done. Single-file launcher created at: ' + path.relative(rootDir, outputPath));
console.log('Size: ' + sizeMb + ' MB');

fs.rmSync(tempDir, { recursive: true, force: true });
