# 任务系统设计

## 愿景

让 AI 成为用户 Pod 的智能管家，自主地帮助用户管理和处理数据。

## 解决什么问题

### 传统方案的问题

1. **固化流程难以进化**：传统的自动化流程（如 IFTTT、Zapier）一旦配置就锁死，无法随着理解加深而改进
2. **策略难以满足所有人**：不同用户对"什么时候处理"、"处理到什么程度"有不同期望，硬编码策略众口难调
3. **成本与效果难平衡**：全量处理成本高，按需处理又需要复杂的决策逻辑

### 我们的解法

**让 AI 自己决策**：我们只提供工具和标准，AI 根据上下文自主决定用什么工具、做到什么程度。

## 设计原则

### 1. 消息驱动

任务系统是一个**消息路由器**：
- 接收消息
- 路由到对应的 AI Agent
- 记录执行状态

### 2. 工具与标准分离

| 我们提供 | AI 决定 |
|---------|--------|
| 工具（API、Lib） | 用什么工具 |
| 标准（规范文档） | 做到什么程度 |
| 存储规范 | 什么时候做 |

### 3. AI 可以写代码

AI 不仅能调用 API，还能生成代码来完成任务：

- **Python**：用 `langchain-text-splitters` 分块、用 `pypdf` 提取 TOC
- **Shell**：调用命令行工具
- **任何合适的方式**：AI 选择最佳方案

这让 AI 不受限于我们预先封装的工具。

### 4. 不做固化流程

- AI 的使命是**帮助用户**，不是执行固定流程
- 随着 AI 理解加深，处理方式持续进化
- 比如"用户添加待办"：早期只同步消息，后来可能关联文件、提醒最佳时间...

### 4. 用户 ROI 最大化

AI 始终平衡用户的投入产出比：
- **渐进式处理**：不一次做到最深，按需逐步深入
- **缓存已完成的工作**：避免重复投入
- **根据重要程度分配资源**：收藏的、常用的值得更多投入

## 核心模型

### Task（任务）

```typescript
interface Task {
  id: string;           // 任务 ID
  agent: string;        // 发给哪个 AI Agent
  message: string;      // 任务消息/上下文
  status: TaskStatus;   // pending | running | completed | failed
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  result?: unknown;
  error?: string;
}
```

### Agent（AI 代理）

```typescript
interface Agent {
  name: string;                    // Agent 名称
  description: string;             // Agent 描述
  execute(message, context): Promise<AgentResult>;
}
```

## 工作流程

```
事件发生 → 生成消息 → 创建任务 → 路由到 Agent → AI 执行 → 存储结果
```

### 任务上下文

AI 决策时可获取的上下文信息：

| 上下文 | 来源 | 用途 |
|--------|------|------|
| 消息本身 | 任务 message | 理解要做什么 |
| Subject 状态 | `.meta` | 判断已做到什么程度 |
| 用户行为 | LDP 查询 | 收藏、最近访问、提及频率 |
| 文件属性 | LDP 查询 | 类型、大小、创建时间 |
| 关联资源 | LDP 查询 | 所在目录、相关文件 |

AI 综合这些上下文，自主决定：
- 是否需要处理
- 处理到什么程度
- 使用什么工具
- 如何存储结果

### 示例

```
用户上传文件
    ↓
message: "用户在 </docs/> 上传了文件 </docs/report.pdf>"
    ↓
Task { agent: "indexing", message: "..." }
    ↓
IndexAgent 收到消息
    ↓
AI 自己决定：检查文件类型、判断重要程度、选择处理深度、调用工具、存储结果
```

## 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                      事件源                              │
│  (文件变更 / 用户操作 / 定时触发 / 外部调用)              │
└─────────────────────┬───────────────────────────────────┘
                      │ 生成消息
                      ▼
┌─────────────────────────────────────────────────────────┐
│                   TaskQueue                              │
│  - 创建任务                                              │
│  - 路由到 Agent                                          │
│  - 记录状态                                              │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│               Claude Agent (via SDK)                     │
│  - 接收消息 + System Prompt                              │
│  - 自主决策                                              │
│  - 调用 MCP 工具                                         │
│  - 可写代码执行                                          │
│  - 按规范存储                                            │
└─────────────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│                   MCP Servers                            │
│  - JINA MCP (Reader/Search)                              │
│  - File System MCP                                       │
│  - 其他 MCP...                                           │
└─────────────────────────────────────────────────────────┘
```

## MCP 配置

AI Agent 通过 MCP (Model Context Protocol) 访问外部工具。

### 可用 MCP 服务器

| MCP Server | 提供工具 | 说明 |
|------------|---------|------|
| **jina-ai/MCP** | Reader, Search | 解析 URL、网络搜索 |
| **filesystem** | read, write, list | 文件系统操作 |
| **bash** | execute | 命令执行（包括 Python） |

### 配置示例

```json
{
  "mcpServers": {
    "jina": {
      "command": "npx",
      "args": ["-y", "@jina-ai/mcp-server"],
      "env": {
        "JINA_API_KEY": "${from_pod_credentials}"
      }
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    }
  }
}
```

## Agent 规范

每个 Agent 有独立的规范文档，定义：
- 可用工具
- 相关标准
- 存储规范

| Agent | 职责 | 规范文档 |
|-------|------|---------|
| indexing | 文档索引 | [indexing-agent.md](./indexing-agent.md) |

## 为什么这样设计

### 为什么用消息而不是结构化参数？

消息是自然语言，AI 可以从中提取需要的信息，也可以处理我们没预料到的场景。

### 为什么不做策略配置？

- 策略配置需要用户理解复杂概念
- 配置完后锁死，无法进化
- AI 可以根据上下文动态决策，比静态配置更灵活

### 为什么不做固化流程？

- 固化流程有开发、测试、发布的完整生命周期
- 固化后不感知 AI 能力的进化
- 全走 AI，等跑出稳定模式后再考虑固化降本

## 存储

### 1. 任务存储

任务本身的存储，记录"做了什么"。

**位置**：`/tasks/{YYYY-MM-DD}.ttl`（按天分片）

```turtle
</tasks/2026-01-09.ttl#task-abc123> a udfs:Task ;
    udfs:agent "indexing" ;
    udfs:message "用户在 </docs/> 上传了文件 </docs/report.pdf>" ;
    udfs:status "completed" ;
    udfs:createdAt "2026-01-09T10:00:00Z"^^xsd:dateTime ;
    udfs:completedAt "2026-01-09T10:00:05Z"^^xsd:dateTime .
```

### 2. Subject 状态存储

资源（Subject）的处理状态，记录"做到了什么程度"。

**位置**：资源的 `.meta` 辅助资源

**作用**：
- AI 读取状态，判断是否需要继续处理
- 避免重复工作
- 支持渐进式处理
- 披露进度和中间状态

**示例**：
```turtle
# /docs/report.pdf.meta

</docs/report.pdf> udfs:indexLevel "L1" ;
    udfs:lastIndexedAt "2026-01-09T10:00:00Z"^^xsd:dateTime ;
    udfs:cachedMarkdown </docs/report.pdf.md> .
```

### 两者的关系

| 存储 | 记录 | 用途 |
|------|------|------|
| 任务存储 | 做了什么（过程） | 追溯、调试、统计 |
| Subject 状态 | 做到什么程度（状态和进度） | AI 决策依据 |

AI 处理时：
1. 读取 Subject 状态 → 判断当前程度
2. 决定是否需要进一步处理
3. 执行处理，更新进度
4. 更新 Subject 状态
5. 记录任务完成

## 经验与探索的平衡

### 为什么不做固化流程

固化流程的问题：
- 需要完整的开发、测试、发布生命周期
- 一旦固化就锁死在某个认知阶段
- AI 进化了，固化流程不感知
- 用户得不到更好的帮助

### 当前策略

**全走 AI，积累经验**：
- 现阶段所有任务都由 AI 处理
- 让 AI 在实际场景中探索最佳处理方式
- 积累数据，观察模式

### 未来考虑

当某个模式足够稳定、高频时，可以考虑固化：
- 降低 AI 调用成本
- 提高响应速度
- 但要保留 AI 升级的能力

**固化的前提**：
- 模式已经跑了足够长时间
- 用户反馈稳定正向
- 固化后仍可被 AI 覆盖升级

**本质**：固化是优化手段，不是目标。目标始终是帮助用户。
